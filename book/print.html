<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go gRPC 简明指南</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Go gRPC Tutorial">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/hello-grpc.html"><strong aria-hidden="true">1.1.</strong> Hello gRPC</a></li><li class="chapter-item expanded "><a href="basic/stream.html"><strong aria-hidden="true">1.2.</strong> gRPC 流</a></li><li class="chapter-item expanded "><a href="basic/protobuf.html"><strong aria-hidden="true">1.3.</strong> Protobuf</a></li></ol></li><li class="chapter-item expanded "><a href="advance/index.html"><strong aria-hidden="true">2.</strong> 进阶</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advance/interceptor.html"><strong aria-hidden="true">2.1.</strong> 拦截器</a></li><li class="chapter-item expanded "><a href="advance/auth.html"><strong aria-hidden="true">2.2.</strong> 安全认证</a></li><li class="chapter-item expanded "><a href="advance/metadata.html"><strong aria-hidden="true">2.3.</strong> metadata</a></li><li class="chapter-item expanded "><a href="advance/monitor/index.html"><strong aria-hidden="true">2.4.</strong> 监控</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advance/monitor/log.html"><strong aria-hidden="true">2.4.1.</strong> log</a></li><li class="chapter-item expanded "><a href="advance/monitor/metrics.html"><strong aria-hidden="true">2.4.2.</strong> metrics</a></li><li class="chapter-item expanded "><a href="advance/monitor/tracing.html"><strong aria-hidden="true">2.4.3.</strong> tracing</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ecosystem/index.html"><strong aria-hidden="true">3.</strong> 生态</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/gateway.html"><strong aria-hidden="true">3.1.</strong> gRPC Gateway</a></li><li class="chapter-item expanded "><a href="ecosystem/middleware.html"><strong aria-hidden="true">3.2.</strong> gRPC Middleware</a></li><li class="chapter-item expanded "><a href="ecosystem/grpcurl.html"><strong aria-hidden="true">3.3.</strong> grpcurl</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference.html">参考</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go gRPC 简明指南</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<hr />
<style>
    #logo-area{background:#43484d;text-align:center;padding-bottom:20px;}
    #logo-go{height: 100px;}
    #logo-grpc{height: 60px;}
</style>
<div id="logo-area">
    <img src="assets/logo-gopher.png" alt="logo" id="logo-go">
    <img src="assets/logo-grpc.png" alt="logo" id="logo-grpc">
</div>
<p><a href="https://grpc.io/">gRPC</a> 是一个高性能、开源、通用的 RPC 框架，由 Google 推出，基于 <a href="https://http2.github.io/">HTTP2</a> 协议标准设计开发，采用 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a> 数据序列化协议，支持多种开发语言，广泛应用于分布式系统服务间的调用。</p>
<p>本项目旨在通过一些简单的示例，提供一个简明的 go gRPC 使用指南，帮助新手快速学会使用 gRPC，而非深究其底层原理，内容包含 gRPC 常用的功能特性，以及 gRPC 生态中的一些工具。</p>
<blockquote>
<p>本项目及源码地址：<a href="https://github.com/jergoo/go-grpc-tutorial">go-grpc-tutorial</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<hr />
<p>这个部分通过创建一个简单的服务说明 go gRPC 的基本使用方法和场景，并介绍 protobuf 的基本语法。</p>
<h2 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h2>
<h3 id="protobuf-编译器"><a class="header" href="#protobuf-编译器">protobuf 编译器</a></h3>
<p>项目地址：<a href="https://github.com/google/protobuf">google/protobuf</a></p>
<p>这里使用<code>brew</code>工具安装，也可以下载编译好的可执行文件：</p>
<pre><code class="language-sh">$ brew install protobuf
</code></pre>
<p>执行<code>protoc</code>命令查看当前版本：</p>
<pre><code class="language-sh">$ protoc --version
libprotoc 3.21.6
</code></pre>
<h3 id="go-编译插件"><a class="header" href="#go-编译插件">go 编译插件</a></h3>
<p>项目地址：</p>
<ul>
<li><a href="https://github.com/protocolbuffers/protobuf-go">protobuf-go</a></li>
<li><a href="https://github.com/grpc/grpc-go">grpc-go</a></li>
</ul>
<p>安装：</p>
<pre><code class="language-sh">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2

$ export PATH=&quot;$PATH:$(go env GOPATH)/bin&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-grpc"><a class="header" href="#hello-grpc">Hello gRPC</a></h1>
<hr />
<p>从一个简单的示例说明 go gRPC 的基本使用流程，实现一个 PingPong 服务，客户端发送 ping 请求，服务端返回 pong 响应。</p>
<p><strong>源码目录：</strong></p>
<pre><code>|—- src/
	|-- ping/
		|—— client.go // 客户端
		|—— server.go // 服务端
	|—- protos/ping/
		|—— ping.proto   // protobuf描述文件
		|—— ping.pb.go   // protoc编译生成
    	|-- ping_grpc.pb.go // protoc编译生成
</code></pre>
<h2 id="编写-protobuf-文件"><a class="header" href="#编写-protobuf-文件">编写 protobuf 文件</a></h2>
<pre><code class="language-protobuf">// src/protos/ping/ping.proto
syntax = &quot;proto3&quot;; // 指定proto版本
package protos;     // 指定包名

// 指定go包路径
option go_package = &quot;protos/ping&quot;;

// 定义PingPong服务
service PingPong {
    // Ping 发送 ping 请求，接收 pong 响应
    rpc Ping(PingRequest) returns (PongResponse);
}

// PingRequest 请求结构
message PingRequest {
    string value = 1; // value字段为string类型
}

// PongResponse 响应结构
message PongResponse {
    string value = 1; // value字段为string类型
}
</code></pre>
<p>定义了一个名为 <code>PingPong</code> 的 service，包含一个 <code>Ping</code> 方法，同时声明了 <code>PingRequest</code> 和 <code>PongResponse</code> 消息结构用于请求和响应。客户端使用 <code>PingRequest</code> 参数调用 <code>Ping</code> 方法请求服务端，服务端响应 <code>PongResponse</code> 消息，一个基本的服务就定义好了。</p>
<h2 id="编译-protobuf-文件"><a class="header" href="#编译-protobuf-文件">编译 protobuf 文件</a></h2>
<pre><code class="language-sh">$ cd src
$ protoc --go_out=. --go-grpc_out=. ./protos/ping/ping.proto
</code></pre>
<p>在src目录执行编译命令，会在目录 <code>src/protos/ping</code> 内生成两个文件 <code>ping.pb.go</code> 和 <code>ping_grpc.pb.go</code>。可以大概看一下这两个文件的内容，<code>ping.pb.go</code> 包含了之前定义的两个message相关的结构，<code>ping_grpc.pb.go</code> 包含了定义的service相关的客户端和服务端接口，<strong>不要修改这两个文件的内容</strong>。</p>
<h2 id="实现服务端接口"><a class="header" href="#实现服务端接口">实现服务端接口</a></h2>
<pre><code class="language-go">// src/ping/server.go
package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;

	&quot;google.golang.org/grpc&quot;

	pb &quot;github.com/jergoo/go-grpc-tutorial/protos/ping&quot; // 引入编译生成的包
)

// PingPongServer 实现 pb.PingPongServer 接口
type PingPongServer struct {
	pb.UnimplementedPingPongServer
}

// Ping 单次请求-响应模式
func (s *PingPongServer) Ping(ctx context.Context, req *pb.PingRequest) (*pb.PongResponse, error) {
	return &amp;pb.PongResponse{Value: &quot;pong&quot;}, nil
}

// 启动server
func main() {
	srv := grpc.NewServer()
	// 注册 PingPongServer
	pb.RegisterPingPongServer(srv, &amp;PingPongServer{})
	lis, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&quot;listen on 1234&quot;)
	srv.Serve(lis)
}
</code></pre>
<p>服务端引入编译生成的包，定义一个 <code>PingPongServer</code> 用于实现约定的接口，接口描述可以查看 <code>ping_grpc.pb.go</code> 文件中的 <code>PingPongServer</code> 接口。实例化 grpc Server 并注册 <code>PingPongServer</code> 开始提供服务。</p>
<h2 id="客户端调用"><a class="header" href="#客户端调用">客户端调用</a></h2>
<pre><code class="language-go">// src/ping/client.go
package main

import (
	&quot;context&quot;
	&quot;log&quot;

	&quot;google.golang.org/grpc&quot;

	pb &quot;github.com/jergoo/go-grpc-tutorial/protos/ping&quot; // 引入编译生成的包
)

// Ping 单次请求-响应模式
func Ping() {
	conn, err := grpc.Dial(&quot;localhost:1234&quot;, grpc.WithInsecure())
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	// 实例化客户端并调用
	client := pb.NewPingPongClient(conn)
	res, err := client.Ping(context.Background(), &amp;pb.PingRequest{Value: &quot;ping&quot;})
	if err != nil {
		log.Fatal(err)
	}
	log.Println(res.Value)
}
</code></pre>
<p>客户端初始化连接，使用 <code>ping_grpc.pb.go</code> 中的 <code>PingPongClient</code> 实例调用 <code>Ping</code> 方法，即可向服务端发起请求并获取响应，就像调用本地方法一样。</p>
<hr />
<blockquote>
<p>以上就是一个最基础的 gRPC 服务，使用非常简单，底层网络细节全部由 gRPC 处理，开发者只需要关注业务接口设计和实现，基本流程如下：</p>
<ol>
<li>编写 protobuf 描述文件，定义消息结构和服务接口</li>
<li>编译 protobuf 文件，生成服务端和客户端接口代码</li>
<li>实现 <code>*_grpc.pb.go</code> 文件中描述的服务端接口</li>
<li>使用 <code>*_grpc.pb.go</code> 文件中的client调用服务</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc-流"><a class="header" href="#grpc-流">gRPC 流</a></h1>
<hr />
<p>从其名称可以理解，流就是持续不断的传输。有一些业务场景请求或者响应的数据量比较大，不适合使用普通的 RPC 调用通过一次请求-响应处理，一方面是考虑数据量大对请求响应时间的影响，另一方面业务场景的设计不一定需要一次性处理完所有数据，这时就可以使用流来分批次传输数据。gRPC支持单向流和双向流，只需要在 service 的 rpc 方法描述中通过 <code>stream</code> 关键字指定启用流特性就好了，下面通过两个示例来说明使用方法。</p>
<p><strong>源码目录：</strong></p>
<pre><code>|—- src/
	|-- ping/
		|—— client.go // 客户端
		|—— server.go // 服务端
	|—- protos/ping/
		|—— ping.proto   // protobuf描述文件
		|—— ping.pb.go   // protoc编译生成
    	|-- ping_grpc.pb.go // protoc编译生成
</code></pre>
<h2 id="单向流"><a class="header" href="#单向流">单向流</a></h2>
<p>单向流是指客户端和服务端只有一端开启流特性，这里的单向特指<strong>发送数据的方向</strong>。</p>
<ul>
<li>当服务端开启流时，客户端和普通 RPC 调用一样通过一次请求发送数据，服务端通过流分批次响应。</li>
<li>当客户端开启流时，客户端通过流分批次发送请求数据，服务端接完所有数据后统一响应一次。</li>
</ul>
<h3 id="服务端流"><a class="header" href="#服务端流">服务端流</a></h3>
<p>定义一个 <code>MultiPong</code> 方法，在服务端开启流，功能是接收到客户端的请求后响应10次 pong 消息。</p>
<pre><code class="language-protobuf">...

service PingPong {
    // 服务端流模式，在响应消息前添加 stream 关键字
    rpc MultiPong(PingRequest) returns (stream PongResponse);
}

...
</code></pre>
<p><strong>服务端实现</strong>：第二个参数为 stream 对象的引用，可以通过它的 <code>Send</code> 方法发送数据。</p>
<pre><code class="language-go">// src/ping/server.go

// MultiPong 服务端流模式
func (s *PingPongServer) MultiPong(req *pb.PingRequest, stream pb.PingPong_MultiPongServer) error {
	for i := 0; i &lt; 10; i++ {
		data := &amp;pb.PongResponse{Value: &quot;pong&quot;}
		// 发送消息
		err := stream.Send(data)
		if err != nil {
			return err
		}
	}
	return nil
}
</code></pre>
<p><strong>客户端实现</strong>：请求方式和普通 RPC 没有区别，重点关注对响应数据流的处理，通过一个 for 循环接收数据直到结束。</p>
<pre><code class="language-go">// src/ping/client.go

func MultiPong() {

    ...
    
    // 获得对 stream 对象的引用
	stream, err := client.MultiPong(context.Background(), &amp;pb.PingRequest{Value: &quot;ping&quot;})
	if err != nil {
		log.Fatal(err)
	}

	// 循环接收响应数据流
	for {
		msg, err := stream.Recv()
		if err != nil {
            // 数据结束
			if err == io.EOF {
				break
			}
			log.Fatal(err)
		}
		log.Println(msg.Value)
	}
}
</code></pre>
<h3 id="客户端流"><a class="header" href="#客户端流">客户端流</a></h3>
<p>定义一个 <code>MultiPing</code> 方法，在客户端开启流，功能是持续发送多个 ping 请求，服务端统一响应一次。</p>
<pre><code class="language-protobuf">...

service PingPong {
	// 客户端流模式，在请求消息前添加 stream 关键字
	rpc MultiPing(stream PingRequest) returns (PongResponse);
}

...
</code></pre>
<p><strong>服务端实现</strong>：只有一个参数为 stream 对象的引用，可以通过它的 <code>Recv</code> 方法接收数据。使用 <code>SendAndClose</code> 方法关闭流并响应，服务端可以根据需要提前关闭。</p>
<pre><code class="language-go">// src/ping/server.go

// MultiPing 客户端流模式
func (s *PingPongServer) MultiPing(stream pb.PingPong_MultiPingServer) error {
	msgs := []string{}
	for {
		// 提前结束接收消息
		if len(msgs) &gt; 5 {
			return stream.SendAndClose(&amp;pb.PongResponse{Value: &quot;ping enough, max 5&quot;})
		}

		msg, err := stream.Recv()
		if err != nil {
			// 客户端消息结束，返回响应信息
			if err == io.EOF {
				return stream.SendAndClose(&amp;pb.PongResponse{Value: fmt.Sprintf(&quot;got %d ping&quot;, len(msgs))})
			}
			return err
		}
		msgs = append(msgs, msg.Value)
	}
}
</code></pre>
<p><strong>客户端实现</strong>：调用 <code>MultiPing</code> 方法时不再指定请求参数，而是通过返回的 stream 对象的 <code>Send</code> 分批发送数据。</p>
<pre><code class="language-go">// src/ping/client.go

func MultiPing() {
    ...

    // 调用并得到 stream 对象
    stream, err := client.MultiPing(context.Background())
	if err != nil {
		log.Fatal(err)
	}

	// 发送数据
	for i := 0; i &lt; 6; i++ {
		data := &amp;pb.PingRequest{Value: &quot;ping&quot;}
		err = stream.Send(data)
		if err != nil {
			log.Fatal(err)
		}
	}

	// 发送结束并获取服务端响应
	res, err := stream.CloseAndRecv()
	if err != nil {
		log.Fatal(err)
	}

	log.Println(res.Value)
}
</code></pre>
<blockquote>
<p>运行结果：</p>
<pre><code class="language-sh">// 发送5个ping
2022/09/27 00:00:00 got 5 ping

// 发送10个ping
2022/09/27 00:00:00 ping enough, max 5
</code></pre>
</blockquote>
<h2 id="双向流"><a class="header" href="#双向流">双向流</a></h2>
<p>双向流是指客户端在发送数据和服务端响应数据的过程中都启用流特性，实际上单向流只是双向流的特例，有了上面的基础，双向流就很好理解了。</p>
<p>定义一个 <code>MultiPingPong</code> 方法，在客户端和服务端都开启流，功能是服务端每接收到两个 ping 就响应一次 pong。</p>
<pre><code class="language-protobuf">...

service PingPong {
	// 双向流模式
	rpc MultiPingPong(stream PingRequest) returns (stream PongResponse);
}

...
</code></pre>
<p><strong>服务端实现</strong>：同样通过 stream 的 <code>Recv</code> 和 <code>Send</code> 方法接收和发送数据。</p>
<pre><code class="language-go">// src/ping/server.go

func (s *PingPongServer) MultiPingPong(stream pb.PingPong_MultiPingPongServer) error {
	msgs := []string{}
	for {
		// 接收消息
		msg, err := stream.Recv()
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
		msgs = append(msgs, msg.Value)

		// 每收到两个消息响应一次
		if len(msgs)%2 == 0 {
			err = stream.Send(&amp;pb.PongResponse{Value: &quot;pong&quot;})
			if err != nil {
				return err
			}
		}
	}
	return nil
}
</code></pre>
<p><strong>客户端实现</strong>：这里在另外一个 goroutine 里处理接收数据的逻辑来演示同时发送和接收数据。</p>
<pre><code class="language-go">// src/ping/client.go
func MultiPingPong() {
    ...

	stream, err := client.MultiPingPong(context.Background())
	if err != nil {
		log.Fatal(err)
	}

	// 在另一个goroutine中处理接收数据
	c := make(chan struct{})
	go func(stream pb.PingPong_MultiPingPongClient, c chan struct{}) {
        defer func() {
			c &lt;- struct{}{}
		}()
		for {
			msg, err := stream.Recv()
			if err != nil {
				if err == io.EOF {
					break
				}
				log.Fatal(err)
			}
			log.Printf(&quot;recv:%s\n&quot;, msg.Value)
		}
	}(stream, c)

	// 发送数据
	for i := 0; i &lt; 6; i++ {
		data := &amp;pb.PingRequest{Value: &quot;ping&quot;}
		err = stream.Send(data)
		if err != nil {
			log.Fatal(err)
		}
		log.Printf(&quot;send:%s\n&quot;, data.Value)

        // 延时一段时间发送，等待响应结果
		time.Sleep(500 * time.Millisecond)
	}

	// 结束发送
	stream.CloseSend()
	// 等待接收完成
	&lt;-c
}

</code></pre>
<blockquote>
<p>运行结果：</p>
<pre><code class="language-sh">2022/09/29 09:09:59 send:ping
2022/09/29 09:10:00 send:ping
2022/09/29 09:10:00 recv:pong
2022/09/29 09:10:00 send:ping
2022/09/29 09:10:01 send:ping
2022/09/29 09:10:01 recv:pong
2022/09/29 09:10:01 send:ping
2022/09/29 09:10:02 send:ping
2022/09/29 09:10:02 recv:pong
</code></pre>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h1>
<hr />
<p>ProtoBuf 是由 Google 开发的一种数据描述语言，应用于跨语言的接口规范描述，同时也是一种数据序列化协议（类似于XML、JSON），能够将数据进行序列化，广泛应用在数据存储、通信协议等方面。这里只介绍基本语法，重点关注如何描述一个服务，更多详细语法及高级特性请查看<a href="https://developers.google.com/protocol-buffers/">官方文档</a></p>
<h2 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h2>
<p>一个 protobuf 描述文件以<code>.proto</code>做为文件后缀，基本由三部分构成：</p>
<ul>
<li>头部区域声明版本、包名、导入包及文件级别的option等信息</li>
<li>定义 service 及其 rpc 方法描述</li>
<li>定义 message/enum 等自义定数据类型</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">// -------------------- 头部区域 ----------------------------
syntax = &quot;proto3&quot;;                        // 指定proto版本号，最新版使用proto3
import &quot;some other package&quot;;              // 导入其它包
package pacakge_name;                     // 指定包名

option go_package = &quot;go package path&quot;;    // go package 文件选项

// -------------------- 服务描述 ----------------------------

service ServiceName {
    rpc FuncName(Request) returns (Response);
}

// -------------------- 自定义数据类型 ----------------------------

message Request {
    string value = 1;
}

message Response {
    string value = 1;
}

</code></pre>
<p><strong>规范</strong></p>
<ul>
<li>除结构定义外的语句以分号结尾，结构定义包括：message、service、enum</li>
<li>message 命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li>
<li>enums 类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式</li>
<li>service 名称与 rpc 方法名统一采用驼峰式命名</li>
<li>支持以 <code>//</code> 开头的单行注释</li>
</ul>
<h2 id="头部区域"><a class="header" href="#头部区域">头部区域</a></h2>
<p>首行要求明确声明使用的 protobuf 版本</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;; 
</code></pre>
<h3 id="导入"><a class="header" href="#导入">导入</a></h3>
<p>可以使用import语句导入使用其它 protobuf 描述文件中声明的类型，protoc 编译器会在编译命令中 <code>-I / --proto_path</code>参数指定的目录中查找导入的文件，如果没有指定该参数，默认在当前目录中查找。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;; 
import &quot;google/protobuf/wrappers.proto&quot;; // 导入其它包

...

service SomeService {
    // 使用包路径引用导入包的类型
    rpc getInfo(google.protobuf.StringValue) returns (Response);
}

</code></pre>
<h3 id="包名"><a class="header" href="#包名">包名</a></h3>
<p>在<code>.proto</code>文件中使用<code>package</code>声明包名，避免命名冲突。</p>
<pre><code>syntax = &quot;proto3&quot;;
package foo.bar;
message Open {...}
</code></pre>
<p>在其他的消息格式定义中可以使用<strong>包名+消息名</strong>的方式来使用类型，如：</p>
<pre><code>message Foo {
    ...
    foo.bar.Open open = 1;
    ...
}
</code></pre>
<h2 id="message"><a class="header" href="#message">message</a></h2>
<p>一个 <code>message</code> 定义描述了一个消息格式，是一个复合类型，和编程语言的结构体类似，protobuf 内置了一些基本类型，使用基本类型和其它复合类型组合定义一个 <code>message</code> 类型。</p>
<ul>
<li>字段声明格式：<code>[类型] [字段名] = [Tag];</code></li>
<li>所有的字段需要前置声明数据类型，除了 protobuf 内置基本类型也可以是其它 message 类型</li>
<li>每个字段都有一个<strong>唯一的数值标签</strong>，这些标签用于标识该字段在消息中的二进制格式，使用中的类型不应该随意改动</li>
<li>可以针对 message 和字段添加注释，注释内容会同步到编译生成的源码文件中</li>
<li>可以在类型名前使用 <code>repeated</code> 关键词，声明该字段为数组类型</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">// SearchRequest 搜索请求
message SearchRequest {
    string keyword = 1;     // 查询关键词
    int32  page_no = 2;     // 页码
    int32  page_size = 3;   // 数量
    repeated int32 arr = 4; // 数组
}
</code></pre>
<h3 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>source</th><th>整型</th><th>浮点</th><th>布尔</th><th>字符串</th><th>字节数组</th></tr></thead><tbody>
<tr><td>protobuf</td><td>int32/uint32/int64/uint64</td><td>float/double</td><td>bool</td><td>string</td><td>bytes</td></tr>
<tr><td>go</td><td>int32/uint32/int64/uint64</td><td>float32/float64</td><td>bool</td><td>string</td><td>[]byte</td></tr>
</tbody></table>
</div>
<h3 id="enum类型"><a class="header" href="#enum类型">enum类型</a></h3>
<p>当定义一个 message 时，想要一个字段只能是一个预定义好的值列表内的一个值，就需要用到enum类型了。<strong>注意：每个enum定义的第一个元素值必须是0</strong></p>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">message Response {
  string value = 1;
  Status status = 2; // 使用Status类型
}

enum Status {
    OK = 0;
    FAIL = 1;
}
</code></pre>
<h3 id="map类型"><a class="header" href="#map类型">map类型</a></h3>
<p>proto3支持map类型声明: <code>map&lt;key_type, value_type&gt; field_name = N;</code></p>
<ul>
<li><code>key_type</code>类型可以是内置的基本类型(除浮点类型和<code>bytes</code>)</li>
<li><code>value_type</code>可以是除map以外的任意类型</li>
<li>map字段不支持<code>repeated</code>属性</li>
<li>不要依赖map类型的字段顺序</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">message Project {...}
map&lt;string, Project&gt; projects = 1;
</code></pre>
<h2 id="service"><a class="header" href="#service">service</a></h2>
<p>service 描述一个RPC服务的接口，使用 <code>rpc</code> 关键字描述方法的签名，方法支持单次请求-响应(unary)和 stream 模式。protoc编译器会根据所选择的不同语言生成服务接口代码。生成的接口代码作为客户端与服务端的约定，服务端必须实现定义的所有接口方法，客户端直接调用同名方法向服务端发起请求。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-protobuf">service ServiceName {
    rpc Single (Request) returns (Response);                  // unary
    rpc ServerStream (Request) returns (stream Response);     // server stream
    rpc ClientStream (stream Request) returns (Response);     // client stream
    rpc BiStream (stream Request) returns (stream Response);  // bidirectional stream
}
</code></pre>
<h2 id="编译"><a class="header" href="#编译">编译</a></h2>
<p>通过定义好的 <code>.proto</code> 文件生成各种语言的代码，需要安装编译器 <code>protoc</code> 及对应语言的插件。参考Github项目<a href="https://github.com/google/protobuf">google/protobuf</a>安装编译器.</p>
<p><strong>示例命令：</strong></p>
<pre><code class="language-sh">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --go-grpc_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto
</code></pre>
<h2 id="protobufgo转换"><a class="header" href="#protobufgo转换">Protobuf⇢Go转换</a></h2>
<p>我们定义一个示例文件对照说明常用结构的 protobuf 到 go 的转换，只说明关键部分代码，详细内容请查看完整文件。</p>
<pre><code class="language-protobuf">// src/protos/example/example.proto

syntax = &quot;proto3&quot;; // 指定proto版本
package example; // 指定包名
option go_package=&quot;protos/example&quot;; // 指定go包路径

// ExampleService 示例
service ExampleService {
    // Single 单次请求响应模式
    rpc Single(Request) returns (Response);
    // ServerStream 服务端流模式
    rpc ServerStream(Request) returns (stream Response);
    // ClientStream 客户端流模式
    rpc ClientStream(stream Request) returns (Response);
    // BiStream 双向流模式
    rpc BiStream(stream Request) returns (stream Response);
}

// Request 请求结构
message Request {
    string value = 1;
}

// Response 响应结构
message Response {
    string valuee = 1;
}

// Msg message 数据类型示例
message Msg {
    int32 i32 = 1;
    int64 i64 = 2;
    float f32 = 3;
    double f64  = 4;
    string str = 5;
    bool boolean = 6;
    bytes byteArr = 7;
    map&lt;string, string&gt; dict = 8;
    Status status = 9;
    EmbMsg embMsg = 10;
    repeated int64 intArr = 11;
}

message EmbMsg {
    string value = 1;
}

// Status 枚举
enum Status {
    OK = 0;
    FAIL = 1;
}

</code></pre>
<p><strong>编译：</strong></p>
<pre><code class="language-sh">&gt; cd src
&gt; protoc --go_out=. --go-grpc_out=. ./protos/example/example.proto
</code></pre>
<h3 id="package"><a class="header" href="#package">package</a></h3>
<p>在proto文件中使用 <code>package</code> 关键字声明包名，默认转换成go中的包名与此一致。这里使用 <code>go_package</code> 选项用于控制编译结果文件的保存路径，这个路径会和编译命令中的<code>--go_out=.</code> 选项的路径拼接。比如这里当前目录是 <code>src</code>, 编译结果输出路径为 <code>./protos/example</code>。</p>
<pre><code class="language-protobuf">package example; // 指定包名
option go_package=&quot;protos/example&quot;; // 指定go包路径
</code></pre>
<h3 id="message-1"><a class="header" href="#message-1">message</a></h3>
<p>protobuf 中的 <code>message</code> 对应 go 中的 <code>struct</code>，全部使用驼峰命名规则，编译结果文件为 <code>{proto file name}.pb.go</code>。</p>
<pre><code class="language-go">// src/protos/example/example.pb.go

// Msg message 数据类型示例
type Msg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	I32     int32             `protobuf:&quot;varint,1,opt,name=i32,proto3&quot; json:&quot;i32,omitempty&quot;`
	I64     int64             `protobuf:&quot;varint,2,opt,name=i64,proto3&quot; json:&quot;i64,omitempty&quot;`
	F32     float32           `protobuf:&quot;fixed32,3,opt,name=f32,proto3&quot; json:&quot;f32,omitempty&quot;`
	F64     float64           `protobuf:&quot;fixed64,4,opt,name=f64,proto3&quot; json:&quot;f64,omitempty&quot;`
	Str     string            `protobuf:&quot;bytes,5,opt,name=str,proto3&quot; json:&quot;str,omitempty&quot;`
	Boolean bool              `protobuf:&quot;varint,6,opt,name=boolean,proto3&quot; json:&quot;boolean,omitempty&quot;`
	ByteArr []byte            `protobuf:&quot;bytes,7,opt,name=byteArr,proto3&quot; json:&quot;byteArr,omitempty&quot;`
	Dict    map[string]string `protobuf:&quot;bytes,8,rep,name=dict,proto3&quot; json:&quot;dict,omitempty&quot; protobuf_key:&quot;bytes,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`
	Status  Status            `protobuf:&quot;varint,9,opt,name=status,proto3,enum=example.Status&quot; json:&quot;status,omitempty&quot;`
	EmbMsg  *EmbMsg           `protobuf:&quot;bytes,10,opt,name=embMsg,proto3&quot; json:&quot;embMsg,omitempty&quot;`
	IntArr  []int64           `protobuf:&quot;varint,11,rep,packed,name=intArr,proto3&quot; json:&quot;intArr,omitempty&quot;`
}

type EmbMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value string `protobuf:&quot;bytes,1,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;`
}

</code></pre>
<p>除了会生成对应的结构外，还会有些工具方法，如字段的getter:</p>
<pre><code class="language-go">func (x *Msg) GetStatus() Status {
	if x != nil {
		return x.Status
	}
	return Status_OK
}
</code></pre>
<p>枚举类型会生成对应名称的常量，同时会有两个map方便使用：</p>
<pre><code class="language-go">// Status 枚举
type Status int32

const (
	Status_OK   Status = 0
	Status_FAIL Status = 1
)

// Enum value maps for Status.
var (
	Status_name = map[int32]string{
		0: &quot;OK&quot;,
		1: &quot;FAIL&quot;,
	}
	Status_value = map[string]int32{
		&quot;OK&quot;:   0,
		&quot;FAIL&quot;: 1,
	}
)
</code></pre>
<h3 id="service-1"><a class="header" href="#service-1">service</a></h3>
<p>针对 service 的编译是由 <code>protoc-gen-go-grpc</code> 插件参与处理，编译结果文件为 <code>{proto file name}_grpc.pb.go</code>。代码中包含服务端和客户端接口的定义，客户端接口已经自动实现了，直接供客户端使用者调用，服务端接口需要由服务提供方实现。</p>
<pre><code class="language-go">// 客户端接口
type ExampleServiceClient interface {
	// Single 单次请求响应模式
	Single(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	// ServerStream 服务端流模式
	ServerStream(ctx context.Context, in *Request, opts ...grpc.CallOption) (ExampleService_ServerStreamClient, error)
	// ClientStream 客户端流模式
	ClientStream(ctx context.Context, opts ...grpc.CallOption) (ExampleService_ClientStreamClient, error)
	// BiStream 双向流模式
	BiStream(ctx context.Context, opts ...grpc.CallOption) (ExampleService_BiStreamClient, error)
}

// 服务端接口
type ExampleServiceServer interface {
	// Single 单次请求响应模式
	Single(context.Context, *Request) (*Response, error)
	// ServerStream 服务端流模式
	ServerStream(*Request, ExampleService_ServerStreamServer) error
	// ClientStream 客户端流模式
	ClientStream(ExampleService_ClientStreamServer) error
	// BiStream 双向流模式
	BiStream(ExampleService_BiStreamServer) error
	mustEmbedUnimplementedExampleServiceServer()
}
</code></pre>
<h2 id="参考文档"><a class="header" href="#参考文档">参考文档</a></h2>
<ul>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide(proto3)</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进阶"><a class="header" href="#进阶">进阶</a></h1>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="拦截器"><a class="header" href="#拦截器">拦截器</a></h1>
<hr />
<p>在应用开发过程中会有这样的需求，就是在请求执行前后做一些通用的处理逻辑，比如记录日志、tracing、身份认证等，在web框架中一般是使用middleware来实现的，gRPC 在客户端和服务端都支持了拦截器功能，用来处理这种业务需求。</p>
<p>下面基于 PingPong 服务做一些扩展来演示拦截器的使用方法。</p>
<p><strong>源码目录：</strong></p>
<pre><code>|—- src/
	|-- interceptor/
		|—— client.go // 客户端
		|—— server.go // 服务端
	|—- protos/ping/
		|—— ping.proto   // protobuf描述文件
		|—— ping.pb.go   // protoc编译生成
    	|-- ping_grpc.pb.go // protoc编译生成
</code></pre>
<h2 id="普通拦截器"><a class="header" href="#普通拦截器">普通拦截器</a></h2>
<p>在客户端和服务端分别实现一个记录请求日志的拦截器，打印请求前后的信息。</p>
<h3 id="服务端"><a class="header" href="#服务端">服务端</a></h3>
<pre><code class="language-go">// src/interceptor/server.go

...

// 服务端拦截器 - 记录请求和响应日志
func serverLogInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	// 前置逻辑
	log.Printf(&quot;[Server] accept request: %s&quot;, info.FullMethod)

	// 处理请求
	response, err := handler(ctx, req)

	// 后置逻辑
	log.Printf(&quot;[Server] response: %s&quot;, response)

	return response, err
}

func main() {
	// 以option的方式添加拦截器
	srv := grpc.NewServer(grpc.UnaryInterceptor(serverLogInterceptor))

...

</code></pre>
<h3 id="客户端"><a class="header" href="#客户端">客户端</a></h3>
<pre><code class="language-golang">// src/inteceptor/client.go

...

// 客户端拦截器 - 记录请求和响应日志
func clientLogInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
	// 前置逻辑
	log.Printf(&quot;[Client] send request: %s&quot;, method)

	// 发起请求
	err := invoker(ctx, method, req, reply, cc, opts...)

	// 后置逻辑
	log.Printf(&quot;[Client] response: %s&quot;, reply)

	return err
}

...

func Ping() {
	// 以option方式添加拦截器
	conn, err := grpc.Dial(&quot;localhost:1234&quot;, grpc.WithInsecure(), grpc.WithUnaryInterceptor(clientLogInterceptor))
	if err != nil {
		log.Fatal(err)
	}

...

</code></pre>
<p>这里分别定义了 <code>serverLogInterceptor</code> 和 <code>clientLogInterceptor</code> 拦截器, 函数的签名定义在 <code>google.golang.org/grpc</code> 包中，分别为 <code>UnaryServerInterceptor</code> 和 <code>UnaryClientInterceptor</code>, 在前置逻辑位置可以对请求信息做处理，在后置逻辑位置可以对响应信息做处理。在初始化服务端和客户端连接时以option的形式配置就好了，同时也支持配置多个拦截器。</p>
<blockquote>
<p>运行结果：</p>
<pre><code class="language-sh">// server
2022/09/27 00:00:00 [Server] accept request: /protos.PingPong/Ping
2022/09/27 00:00:00 [Server] response: value:&quot;pong&quot;

// client
2022/09/27 00:00:00 [Client] send request: /protos.PingPong/Ping
2022/09/27 00:00:00 [Client] response: value:&quot;pong&quot;
</code></pre>
</blockquote>
<h2 id="流拦截器"><a class="header" href="#流拦截器">流拦截器</a></h2>
<h3 id="服务端-1"><a class="header" href="#服务端-1">服务端</a></h3>
<h3 id="客户端-1"><a class="header" href="#客户端-1">客户端</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全认证"><a class="header" href="#安全认证">安全认证</a></h1>
<hr />
<p>gRPC默认内置了两种认证方式：</p>
<ul>
<li>
<p>SSL/TLS认证方式</p>
</li>
<li>
<p>基于Token的认证方式</p>
</li>
</ul>
<p>同时，gRPC提供了接口用于扩展自定义认证方式</p>
<h2 id="tls认证示例"><a class="header" href="#tls认证示例">TLS认证示例</a></h2>
<p>这里直接扩展hello项目，实现TLS认证机制</p>
<p>首先需要准备证书，在hello目录新建keys目录用于存放证书文件。</p>
<h3 id="证书制作"><a class="header" href="#证书制作">证书制作</a></h3>
<h4 id="制作私钥-key"><a class="header" href="#制作私钥-key">制作私钥 (.key)</a></h4>
<pre><code class="language-sh"># Key considerations for algorithm &quot;RSA&quot; ≥ 2048-bit
$ openssl genrsa -out server.key 2048
    
# Key considerations for algorithm &quot;ECDSA&quot; ≥ secp384r1
# List ECDSA the supported curves (openssl ecparam -list_curves)
$ openssl ecparam -genkey -name secp384r1 -out server.key
</code></pre>
<h4 id="自签名公钥x509-pem-encodings-pemcrt"><a class="header" href="#自签名公钥x509-pem-encodings-pemcrt">自签名公钥(x509) (PEM-encodings <code>.pem</code>|<code>.crt</code>)</a></h4>
<pre><code class="language-sh">$ openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
</code></pre>
<h4 id="自定义信息"><a class="header" href="#自定义信息">自定义信息</a></h4>
<pre><code class="language-sh">-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:XxXx
Locality Name (eg, city) []:XxXx
Organization Name (eg, company) [Internet Widgits Pty Ltd]:XX Co. Ltd
Organizational Unit Name (eg, section) []:Dev
Common Name (e.g. server FQDN or YOUR name) []:server name
Email Address []:xxx@xxx.com
</code></pre>
<h3 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h3>
<pre><code>|—— hello-tls/
	|—— client/
    	|—— main.go   // 客户端
	|—— server/
    	|—— main.go   // 服务端
|—— keys/				 // 证书目录
	|—— server.key
	|—— server.pem
|—— proto/
	|—— hello/
		|—— hello.proto   // proto描述文件
		|—— hello.pb.go   // proto编译后文件
</code></pre>
<h3 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h3>
<p><code>proto/helloworld.proto</code>及<code>proto/hello.pb.go</code>文件不需要改动</p>
<p>修改服务端代码：server/main.go</p>
<pre><code class="language-golang">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;

	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello&quot;

	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot; // 引入grpc认证包
	&quot;google.golang.org/grpc/grpclog&quot;
)

const (
	// Address gRPC服务地址
	Address = &quot;127.0.0.1:50052&quot;
)

// 定义helloService并实现约定的接口
type helloService struct{}

// HelloService Hello服务
var HelloService = helloService{}

// SayHello 实现Hello服务接口
func (h helloService) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {
	resp := new(pb.HelloResponse)
	resp.Message = fmt.Sprintf(&quot;Hello %s.&quot;, in.Name)

	return resp, nil
}

func main() {
	listen, err := net.Listen(&quot;tcp&quot;, Address)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to listen: %v&quot;, err)
	}

	// TLS认证
	creds, err := credentials.NewServerTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;../../keys/server.key&quot;)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to generate credentials %v&quot;, err)
	}

	// 实例化grpc Server, 并开启TLS认证
	s := grpc.NewServer(grpc.Creds(creds))

	// 注册HelloService
	pb.RegisterHelloServer(s, HelloService)

	grpclog.Println(&quot;Listen on &quot; + Address + &quot; with TLS&quot;)

	s.Serve(listen)
}
</code></pre>
<p>运行：</p>
<pre><code class="language-sh">$ go run main.go

Listen on 127.0.0.1:50052 with TLS
</code></pre>
<p>服务端在实例化grpc Server时，可配置多种选项，TLS认证是其中之一</p>
<p>客户端添加TLS认证：client/main.go</p>
<pre><code class="language-golang">package main

import (
	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello&quot; // 引入proto包

	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot; // 引入grpc认证包
	&quot;google.golang.org/grpc/grpclog&quot;
)

const (
	// Address gRPC服务地址
	Address = &quot;127.0.0.1:50052&quot;
)

func main() {
	// TLS连接
	creds, err := credentials.NewClientTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;server name&quot;)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to create TLS credentials %v&quot;, err)
	}

	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds))
	if err != nil {
		grpclog.Fatalln(err)
	}
	defer conn.Close()

	// 初始化客户端
	c := pb.NewHelloClient(conn)

	// 调用方法
	req := &amp;pb.HelloRequest{Name: &quot;gRPC&quot;}
	res, err := c.SayHello(context.Background(), req)
	if err != nil {
		grpclog.Fatalln(err)
	}

	grpclog.Println(res.Message)
}
</code></pre>
<p>运行：</p>
<pre><code class="language-sh">$ go run main.go

Hello gRPC
</code></pre>
<p>客户端添加TLS认证的方式和服务端类似，在创建连接<code>Dial</code>时，同样可以配置多种选项，后面的示例中会看到更多的选项。</p>
<h2 id="token认证示例"><a class="header" href="#token认证示例">Token认证示例</a></h2>
<p>再进一步，继续扩展hello-tls项目，实现TLS + Token认证机制</p>
<h3 id="目录结构-1"><a class="header" href="#目录结构-1">目录结构</a></h3>
<pre><code>|—— hello_token/
	|—— client/
    	|—— main.go   // 客户端
	|—— server/
    	|—— main.go   // 服务端
|—— keys/             // 证书目录
	|—— server.key
	|—— server.pem
|—— proto/
	|—— hello/
		|—— hello.proto   // proto描述文件
		|—— hello.pb.go   // proto编译后文件
</code></pre>
<h3 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h3>
<p>先修改客户端实现：client/main.go</p>
<pre><code class="language-golang">package main

import (
	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello&quot; // 引入proto包

	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot; // 引入grpc认证包
	&quot;google.golang.org/grpc/grpclog&quot;
)

const (
	// Address gRPC服务地址
	Address = &quot;127.0.0.1:50052&quot;

	// OpenTLS 是否开启TLS认证
	OpenTLS = true
)

// customCredential 自定义认证
type customCredential struct{}

// GetRequestMetadata 实现自定义认证接口
func (c customCredential) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{
		&quot;appid&quot;:  &quot;101010&quot;,
		&quot;appkey&quot;: &quot;i am key&quot;,
	}, nil
}

// RequireTransportSecurity 自定义认证是否开启TLS
func (c customCredential) RequireTransportSecurity() bool {
	return OpenTLS
}

func main() {
	var err error
	var opts []grpc.DialOption

	if OpenTLS {
		// TLS连接
		creds, err := credentials.NewClientTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;server name&quot;)
		if err != nil {
			grpclog.Fatalf(&quot;Failed to create TLS credentials %v&quot;, err)
		}
		opts = append(opts, grpc.WithTransportCredentials(creds))
	} else {
		opts = append(opts, grpc.WithInsecure())
	}

	// 使用自定义认证
	opts = append(opts, grpc.WithPerRPCCredentials(new(customCredential)))

	conn, err := grpc.Dial(Address, opts...)

	if err != nil {
		grpclog.Fatalln(err)
	}

	defer conn.Close()

	// 初始化客户端
	c := pb.NewHelloClient(conn)

	// 调用方法
	req := &amp;pb.HelloRequest{Name: &quot;gRPC&quot;}
	res, err := c.SayHello(context.Background(), req)
	if err != nil {
		grpclog.Fatalln(err)
	}

	grpclog.Println(res.Message)
}
</code></pre>
<p>这里我们定义了一个<code>customCredential</code>结构，并实现了两个方法<code>GetRequestMetadata</code>和<code>RequireTransportSecurity</code>。这是gRPC提供的自定义认证方式，每次RPC调用都会传输认证信息。<code>customCredential</code>其实是实现了<code>grpc/credential</code>包内的<code>PerRPCCredentials</code>接口。每次调用，token信息会通过请求的metadata传输到服务端。下面具体看一下服务端如何获取metadata中的信息。</p>
<p>修改server/main.go中的SayHello方法：</p>
<pre><code class="language-golang">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;

	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello&quot;

	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/codes&quot;
	&quot;google.golang.org/grpc/credentials&quot; // 引入grpc认证包
	&quot;google.golang.org/grpc/grpclog&quot;
	&quot;google.golang.org/grpc/metadata&quot; // 引入grpc meta包
)

const (
	// Address gRPC服务地址
	Address = &quot;127.0.0.1:50052&quot;
)

// 定义helloService并实现约定的接口
type helloService struct{}

// HelloService ...
var HelloService = helloService{}

// SayHello 实现Hello服务接口
func (h helloService) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {
	// 解析metada中的信息并验证
	md, ok := metadata.FromContext(ctx)
	if !ok {
		return nil, grpc.Errorf(codes.Unauthenticated, &quot;无Token认证信息&quot;)
	}

	var (
		appid  string
		appkey string
	)

	if val, ok := md[&quot;appid&quot;]; ok {
		appid = val[0]
	}

	if val, ok := md[&quot;appkey&quot;]; ok {
		appkey = val[0]
	}

	if appid != &quot;101010&quot; || appkey != &quot;i am key&quot; {
		return nil, grpc.Errorf(codes.Unauthenticated, &quot;Token认证信息无效: appid=%s, appkey=%s&quot;, appid, appkey)
	}

	resp := new(pb.HelloResponse)
	resp.Message = fmt.Sprintf(&quot;Hello %s.\nToken info: appid=%s,appkey=%s&quot;, in.Name, appid, appkey)

	return resp, nil
}

func main() {
	listen, err := net.Listen(&quot;tcp&quot;, Address)
	if err != nil {
		grpclog.Fatalf(&quot;failed to listen: %v&quot;, err)
	}

	// TLS认证
	creds, err := credentials.NewServerTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;../../keys/server.key&quot;)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to generate credentials %v&quot;, err)
	}

	// 实例化grpc Server, 并开启TLS认证
	s := grpc.NewServer(grpc.Creds(creds))

	// 注册HelloService
	pb.RegisterHelloServer(s, HelloService)

	grpclog.Println(&quot;Listen on &quot; + Address + &quot; with TLS + Token&quot;)

	s.Serve(listen)
}
</code></pre>
<p>服务端可以从<code>context</code>中获取每次请求的metadata，从中读取客户端发送的token信息并验证有效性。</p>
<p>运行：</p>
<pre><code class="language-sh">$ go run main.go

Listen on 50052 with TLS + Token
</code></pre>
<p>运行客户端程序 client/main.go：</p>
<pre><code>$ go run main.go

// 认证成功结果
Hello gRPC
Token info: appid=101010,appkey=i am key

// 修改key验证认证失败结果：
rpc error: code = 16 desc = Token认证信息无效: appID=101010, appKey=i am not key
</code></pre>
<p><code>google.golang.org/grpc/credentials/oauth</code>包已实现了用于Google API的oauth和jwt验证的方法，使用方法可以参考<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md">官方文档</a>。在实际应用中，我们可以根据自己的业务需求实现合适的验证方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadata"><a class="header" href="#metadata">metadata</a></h1>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="监控"><a class="header" href="#监控">监控</a></h1>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">log</a></h1>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">metrics</a></h1>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing"><a class="header" href="#tracing">tracing</a></h1>
<hr />
<p>grpc内置了客户端和服务端的请求追踪，基于<code>golang.org/x/net/trace</code>包实现，默认是开启状态，可以查看事件和请求日志，对于基本的请求状态查看调试也是很有帮助的，客户端与服务端基本一致，这里以服务端开启trace server为例，修改hello项目服务端代码：</p>
<h2 id="目录结构-2"><a class="header" href="#目录结构-2">目录结构</a></h2>
<pre><code>|—— hello_trace/
	|—— client/
    	|—— main.go   // 客户端
	|—— server/
    	|—— main.go   // 服务端
|—— proto/
	|—— hello/
		|—— hello.proto   // proto描述文件
		|—— hello.pb.go   // proto编译后文件
</code></pre>
<h2 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;net/http&quot;

	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello&quot; // 引入编译生成的包

	&quot;golang.org/x/net/context&quot;
	&quot;golang.org/x/net/trace&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/grpclog&quot;
)

const (
	// Address gRPC服务地址
	Address = &quot;127.0.0.1:50052&quot;
)

// 定义helloService并实现约定的接口
type helloService struct{}

// HelloService Hello服务
var HelloService = helloService{}

// SayHello 实现Hello服务接口
func (h helloService) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {
	resp := new(pb.HelloResponse)
	resp.Message = fmt.Sprintf(&quot;Hello %s.&quot;, in.Name)

	return resp, nil
}

func main() {
	listen, err := net.Listen(&quot;tcp&quot;, Address)
	if err != nil {
		grpclog.Fatalf(&quot;failed to listen: %v&quot;, err)
	}

	// 实例化grpc Server
	s := grpc.NewServer()

	// 注册HelloService
	pb.RegisterHelloServer(s, HelloService)

	// 开启trace
	go startTrace()

	grpclog.Println(&quot;Listen on &quot; + Address)
	s.Serve(listen)
}

func startTrace() {
	trace.AuthRequest = func(req *http.Request) (any, sensitive bool) {
		return true, true
	}
	go http.ListenAndServe(&quot;:50051&quot;, nil)
	grpclog.Println(&quot;Trace listen on 50051&quot;)
}
</code></pre>
<p>这里我们开启一个http服务监听50051端口，用来查看grpc请求的trace信息</p>
<p>运行：</p>
<pre><code class="language-sh">$ go run main.go

Listen on 127.0.0.1:50052                                                       
Trace listen on 50051

# 进入client目录执行一次客户端请求     
</code></pre>
<h2 id="服务端事件查看"><a class="header" href="#服务端事件查看">服务端事件查看</a></h2>
<p>访问：localhost:50051/debug/events，结果如图：</p>
<p><img src="advance/monitor/../_media/grpc_trace_events.jpg" alt="" /></p>
<p>可以看到服务端注册的服务和服务正常启动的事件信息。</p>
<h2 id="请求日志信息查看"><a class="header" href="#请求日志信息查看">请求日志信息查看</a></h2>
<p>访问：localhost:50051/debug/requests，结果如图：</p>
<p><img src="advance/monitor/../_media/grpc_trace_requests.jpg" alt="" /></p>
<p>这里可以显示最近的请求状态，包括请求的服务、参数、耗时、响应，对于简单的状态查看还是很方便的，默认值显示最近10条记录。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc-生态"><a class="header" href="#grpc-生态">gRPC 生态</a></h1>
<hr />
<p>gRPC 的发展非常迅速，从 gRPC 扩展出来的生态包含了各种各样的工具，这部分介绍几个常用的工具。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/grpc-ecosystem">grpc-ecosystem</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc-gateway"><a class="header" href="#grpc-gateway">gRPC Gateway</a></h1>
<hr />
<blockquote>
<p>项目地址：<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a></p>
</blockquote>
<p>源自coreos的一篇博客 <a href="https://coreos.com/blog/grpc-protobufs-swagger.html">Take a REST with HTTP/2, Protobufs, and Swagger</a>。</p>
<p>etcd3 API全面升级为gRPC后，同时要提供REST API服务，维护两个版本的服务显然不太合理，所以<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>诞生了。通过protobuf的自定义option实现了一个网关，服务端同时开启gRPC和HTTP服务，HTTP服务接收客户端请求后转换为grpc请求数据，获取响应后转为json数据返回给客户端。</p>
<p>结构如图：</p>
<p><img src="ecosystem/../_media/grpc_rest_gateway.png" alt="" /></p>
<h2 id="安装grpc-gateway"><a class="header" href="#安装grpc-gateway">安装grpc-gateway</a></h2>
<pre><code class="language-sh">$ go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway

</code></pre>
<h2 id="目录结构-3"><a class="header" href="#目录结构-3">目录结构</a></h2>
<pre><code>|—— hello_http/
	|—— client/
    	|—— main.go   // 客户端
	|—— server/
    	|—— main.go   // GRPC服务端
	|—— server_http/
		|—— main.go   // HTTP服务端
|—— proto/
	|—— google       // googleApi http-proto定义
		|—— api
			|—— annotations.proto
			|—— annotations.pb.go
			|—— http.proto
			|—— http.pb.go
	|—— hello_http/
		|—— hello_http.proto   // proto描述文件
		|—— hello_http.pb.go   // proto编译后文件
		|—— hello_http_pb.gw.go // gateway编译后文件
</code></pre>
<p>这里用到了google官方Api中的两个proto描述文件，直接拷贝不要做修改，里面定义了protocol buffer扩展的HTTP option，为grpc的http转换提供支持。</p>
<h2 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h2>
<p><strong>Step 1. 编写proto描述文件：proto/hello_http.proto</strong></p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package hello_http;
option go_package = &quot;hello_http&quot;;

import &quot;google/api/annotations.proto&quot;;

// 定义Hello服务
service HelloHTTP {
    // 定义SayHello方法
    rpc SayHello(HelloHTTPRequest) returns (HelloHTTPResponse) {
        // http option
        option (google.api.http) = {
            post: &quot;/example/echo&quot;
            body: &quot;*&quot;
        };
    }
}

// HelloRequest 请求结构
message HelloHTTPRequest {
    string name = 1;
}

// HelloResponse 响应结构
message HelloHTTPResponse {
    string message = 1;
}

</code></pre>
<p>这里在原来的<code>SayHello</code>方法定义中增加了http option, POST方式，路由为&quot;/example/echo&quot;。</p>
<p><strong>Step 2. 编译proto</strong></p>
<pre><code class="language-sh">$ cd proto

# 编译google.api
$ protoc -I . --go_out=plugins=grpc,Mgoogle/protobuf/descriptor.proto=github.com/golang/protobuf/protoc-gen-go/descriptor:. google/api/*.proto

# 编译hello_http.proto
$ protoc -I . --go_out=plugins=grpc,Mgoogle/api/annotations.proto=github.com/jergoo/go-grpc-tutorial/proto/google/api:. hello_http/*.proto

# 编译hello_http.proto gateway
$ protoc --grpc-gateway_out=logtostderr=true:. hello_http/hello_http.proto
</code></pre>
<p>注意这里需要编译google/api中的两个proto文件，同时在编译hello_http.proto时使用<code>M</code>参数指定引入包名，最后使用grpc-gateway编译生成<code>hello_http_pb.gw.go</code>文件，这个文件就是用来做协议转换的，查看文件可以看到里面生成的http handler，处理proto文件中定义的路由&quot;example/echo&quot;接收POST参数，调用HelloHTTP服务的客户端请求grpc服务并响应结果。</p>
<p><strong>Step 3: 实现服务端和客户端</strong></p>
<p>server/main.go和client/main.go的实现与hello项目一致，这里不再说明。</p>
<blockquote>
<p>server_http/main.go</p>
</blockquote>
<pre><code class="language-golang">package main

import (
	&quot;net/http&quot;

	&quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;
	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/grpclog&quot;

	gw &quot;github.com/jergoo/go-grpc-tutorial/proto/hello_http&quot;
)

func main() {
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// grpc服务地址
	endpoint := &quot;127.0.0.1:50052&quot;
	mux := runtime.NewServeMux()
	opts := []grpc.DialOption{grpc.WithInsecure()}

	// HTTP转grpc
	err := gw.RegisterHelloHTTPHandlerFromEndpoint(ctx, mux, endpoint, opts)
	if err != nil {
		grpclog.Fatalf(&quot;Register handler err:%v\n&quot;, err)
	}

	grpclog.Println(&quot;HTTP Listen on 8080&quot;)
	http.ListenAndServe(&quot;:8080&quot;, mux)
}
</code></pre>
<p>就是这么简单。开启了一个http server，收到请求后根据路由转发请求到对应的RPC接口获得结果。grpc-gateway做的事情就是帮我们自动生成了转换过程的实现。</p>
<h2 id="运行结果"><a class="header" href="#运行结果">运行结果</a></h2>
<p>依次开启gRPC服务和HTTP服务端：</p>
<pre><code class="language-sh">$ cd hello_http/server &amp;&amp; go run main.go
Listen on 127.0.0.1:50052
</code></pre>
<pre><code class="language-sh">$ cd hello_http/server_http &amp;&amp; go run main.go
HTTP Listen on 8080
</code></pre>
<p>调用grpc客户端：</p>
<pre><code class="language-sh">$ cd hello_http/client &amp;&amp; go run main.go
Hello gRPC.

# HTTP 请求
$ curl -X POST -k http://localhost:8080/example/echo -d '{&quot;name&quot;: &quot;gRPC-HTTP is working!&quot;}'
{&quot;message&quot;:&quot;Hello gRPC-HTTP is working!.&quot;}
</code></pre>
<h2 id="升级版服务端"><a class="header" href="#升级版服务端">升级版服务端</a></h2>
<p>上面的使用方式已经实现了我们最初的需求，<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>项目中提供的示例也是这种使用方式，这样后台需要开启两个服务两个端口。其实我们也可以只开启一个服务，同时提供http和gRPC调用方式。</p>
<p>新建一个项目<code>hello_http_2</code>, 基于<code>hello_tls</code>项目改造。客户端只要修改调用的proto包地址就可以了，这里我们看服务端的实现：</p>
<blockquote>
<p>hello_http_2/server/main.go</p>
</blockquote>
<pre><code class="language-golang">package main

import (
	&quot;crypto/tls&quot;
	&quot;io/ioutil&quot;
	&quot;net&quot;
	&quot;net/http&quot;
	&quot;strings&quot;

	&quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;
	pb &quot;github.com/jergoo/go-grpc-tutorial/proto/hello_http&quot;
	&quot;golang.org/x/net/context&quot;
	&quot;golang.org/x/net/http2&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;
	&quot;google.golang.org/grpc/grpclog&quot;
)

// 定义helloHTTPService并实现约定的接口
type helloHTTPService struct{}

// HelloHTTPService Hello HTTP服务
var HelloHTTPService = helloHTTPService{}

// SayHello 实现Hello服务接口
func (h helloHTTPService) SayHello(ctx context.Context, in *pb.HelloHTTPRequest) (*pb.HelloHTTPResponse, error) {
	resp := new(pb.HelloHTTPResponse)
	resp.Message = &quot;Hello &quot; + in.Name + &quot;.&quot;

	return resp, nil
}

func main() {
	endpoint := &quot;127.0.0.1:50052&quot;
	conn, err := net.Listen(&quot;tcp&quot;, endpoint)
	if err != nil {
		grpclog.Fatalf(&quot;TCP Listen err:%v\n&quot;, err)
	}

	// grpc tls server
	creds, err := credentials.NewServerTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;../../keys/server.key&quot;)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to create server TLS credentials %v&quot;, err)
	}
	grpcServer := grpc.NewServer(grpc.Creds(creds))
	pb.RegisterHelloHTTPServer(grpcServer, HelloHTTPService)

	// gw server
	ctx := context.Background()
	dcreds, err := credentials.NewClientTLSFromFile(&quot;../../keys/server.pem&quot;, &quot;server name&quot;)
	if err != nil {
		grpclog.Fatalf(&quot;Failed to create client TLS credentials %v&quot;, err)
	}
	dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}
	gwmux := runtime.NewServeMux()
	if err = pb.RegisterHelloHTTPHandlerFromEndpoint(ctx, gwmux, endpoint, dopts); err != nil {
		grpclog.Fatalf(&quot;Failed to register gw server: %v\n&quot;, err)
	}

	// http服务
	mux := http.NewServeMux()
	mux.Handle(&quot;/&quot;, gwmux)

	srv := &amp;http.Server{
		Addr:      endpoint,
		Handler:   grpcHandlerFunc(grpcServer, mux),
		TLSConfig: getTLSConfig(),
	}

	grpclog.Infof(&quot;gRPC and https listen on: %s\n&quot;, endpoint)

	if err = srv.Serve(tls.NewListener(conn, srv.TLSConfig)); err != nil {
		grpclog.Fatal(&quot;ListenAndServe: &quot;, err)
	}

	return
}

func getTLSConfig() *tls.Config {
	cert, _ := ioutil.ReadFile(&quot;../../keys/server.pem&quot;)
	key, _ := ioutil.ReadFile(&quot;../../keys/server.key&quot;)
	var demoKeyPair *tls.Certificate
	pair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		grpclog.Fatalf(&quot;TLS KeyPair err: %v\n&quot;, err)
	}
	demoKeyPair = &amp;pair
	return &amp;tls.Config{
		Certificates: []tls.Certificate{*demoKeyPair},
		NextProtos:   []string{http2.NextProtoTLS}, // HTTP2 TLS支持
	}
}

// grpcHandlerFunc returns an http.Handler that delegates to grpcServer on incoming gRPC
// connections or otherHandler otherwise. Copied from cockroachdb.
func grpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
	if otherHandler == nil {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			grpcServer.ServeHTTP(w, r)
		})
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	})
}

</code></pre>
<p>gRPC服务端接口的实现没有区别，重点在于HTTP服务的实现。gRPC是基于http2实现的，<code>net/http</code>包也实现了http2，所以我们可以开启一个HTTP服务同时服务两个版本的协议，在注册http handler的时候，在方法<code>grpcHandlerFunc</code>中检测请求头信息，决定是直接调用gRPC服务，还是使用gateway的HTTP服务。<code>net/http</code>中对http2的支持要求开启https，所以这里要求使用https服务。</p>
<p><strong>步骤</strong></p>
<ul>
<li>注册开启TLS的grpc服务</li>
<li>注册开启TLS的gateway服务，地址指向grpc服务</li>
<li>开启HTTP server</li>
</ul>
<h3 id="运行结果-1"><a class="header" href="#运行结果-1">运行结果</a></h3>
<pre><code class="language-sh">$ cd hello_http_2/server &amp;&amp; go run main.go
gRPC and https listen on: 127.0.0.1:50052
</code></pre>
<pre><code class="language-sh">$ cd hello_http_2/client &amp;&amp; go run main.go
Hello gRPC.

# HTTP 请求
$ curl -X POST -k https://localhost:50052/example/echo -d '{&quot;name&quot;: &quot;gRPC-HTTP is working!&quot;}'
{&quot;message&quot;:&quot;Hello gRPC-HTTP is working!.&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc-middleware"><a class="header" href="#grpc-middleware">gRPC Middleware</a></h1>
<hr />
<blockquote>
<p>项目地址：<a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpcurl"><a class="header" href="#grpcurl">grpcurl</a></h1>
<hr />
<blockquote>
<p>项目地址：<a href="https://github.com/fullstorydev/grpcurl">grpcurl</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<hr />
<blockquote>
<p><strong>Doc &amp; Book</strong></p>
<ul>
<li><a href="https://grpc.io/">gRPC website</a></li>
<li><a href="https://developers.google.com/protocol-buffers">protobuf website</a></li>
<li><a href="https://www.oreilly.com/library/view/grpc-up-and/9781492058328/">gRPC: Up and Running</a></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Projects</strong></p>
<ul>
<li><a href="https://github.com/grpc/grpc">grpc/grpc</a></li>
<li><a href="https://github.com/grpc/grpc-go/">grpc-go</a></li>
<li><a href="https://github.com/google/protobuf">google/protobuf</a></li>
<li><a href="https://github.com/golang/protobuf">golang/protobuf</a></li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware">grpc-middleware</a></li>
<li><a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a></li>
<li><a href="https://github.com/fullstorydev/grpcurl">grpcurl</a></li>
<li><a href="https://buf.build/">buf</a></li>
</ul>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
